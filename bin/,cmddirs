#!/usr/bin/env perl
# DO NOT EDIT -- this is an auto generated file
## no critic
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/CmdDirs.pm"} = <<'APP_CMDDIRS';
  package App::CmdDirs;
  use strict;
  use warnings;
  
  use Cwd;
  
  use App::CmdDirs::Traverser::Base;
  
  our $VERSION;
  BEGIN {
      $VERSION = '1.02';
  }
  
  sub new {
      my ($class, $argv, $options) = @_;
  
      my $self = {};
      $self->{'argv'} = $argv;
      $self->{'options'} = $options;
      bless $self, $class;
  
      return $self;
  }
  
  # Find directories to act upon, choose a traverser, and go
  sub run {
      my ($self) = @_;
  
      # Pull working dir & post-option arguments
      my $topDir = cwd();
      my @argv = @{$self->{'argv'}};
      my $command = $argv[0];
      my @dirs;
  
      # Get any dirs passed on the command line
      foreach (my $x = 1; $x < scalar(@argv); $x++) {
          push @dirs, $argv[$x];
      }
  
      # No directories passed, glob all
      if ($#dirs == -1) {
          @dirs = glob '*';
      }
  
      my $traverser = $self->getTraverser($command, $topDir, \@dirs);
  
      $traverser->traverse($self->{'options'}->{'quiet'});
  
      return 1;
  }
  
  # Create a traverser for specific command types
  sub getTraverser {
      my ($self, $command, $topDir, $dirs) = @_;
      my $traverser;
  
      if ($self->{'options'}{'all'}) {
          $traverser = App::CmdDirs::Traverser::Base->new($command, $topDir, $dirs);
      } elsif ($self->{'options'}->{'git'} || $command =~ /git/) {
          require App::CmdDirs::Traverser::Git;
          $traverser = App::CmdDirs::Traverser::Git->new($command, $topDir, $dirs);
      } elsif ($self->{'options'}->{'svn'} || $command =~ /svn/) {
          require App::CmdDirs::Traverser::Subversion;
          $traverser = App::CmdDirs::Traverser::Subversion->new($command, $topDir, $dirs);
      } else {
          $traverser = App::CmdDirs::Traverser::Base->new($command, $topDir, $dirs);
      }
  
      return $traverser;
  }
  
  1;
APP_CMDDIRS

$fatpacked{"App/CmdDirs/Traverser/Base.pm"} = <<'APP_CMDDIRS_TRAVERSER_BASE';
  package App::CmdDirs::Traverser::Base;
  use strict;
  use warnings;
  
  use Term::ANSIColor;
  
  sub new {
      my ($class, $command, $topDir, $dirs) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{'command'} = $command;
      $self->{'topDir'} = $topDir;
      $self->{'dirs'} = $dirs;
  
      return $self;
  }
  
  # Return false to skip this directory
  sub test {
      # Override this
      return 1;
  }
  
  # Run this class' test() on each directory.  If the test passes, descend
  # into that directory, run $command, and return to the top directory.
  sub traverse {
      my ($self, $quiet) = @_;
  
      my $command = $self->{'command'};
      my $topDir = $self->{'topDir'};
  
      my @dirs = @{$self->{'dirs'}};
      foreach my $dir (@dirs) {
          next if ! -d $dir;
          next if ! $self->test($dir);
  
          # Tell the user what command is going to be run
          unless ($quiet) {
              print color 'bold green';
              print "Performing `$command` in <$dir>\n";
              print color 'reset';
          }
  
          # Descend into the directory & run the command
          chdir $dir;
          system("$command");
          chdir $topDir;
  
          print "\n";
      }
  
      return 1
  }
  
  1;
APP_CMDDIRS_TRAVERSER_BASE

$fatpacked{"App/CmdDirs/Traverser/Git.pm"} = <<'APP_CMDDIRS_TRAVERSER_GIT';
  package App::CmdDirs::Traverser::Git;
  use base 'App::CmdDirs::Traverser::Base';
  use strict;
  use warnings;
  
  # Return false if the passed directory does not have a .git subdirectory
  sub test {
      my ($self, $dir) = @_;
  
      return (-d "$dir/.git");
  }
  
  1;
APP_CMDDIRS_TRAVERSER_GIT

$fatpacked{"App/CmdDirs/Traverser/Subversion.pm"} = <<'APP_CMDDIRS_TRAVERSER_SUBVERSION';
  package App::CmdDirs::Traverser::Subversion;
  use base 'App::CmdDirs::Traverser::Base';
  use strict;
  use warnings;
  
  # Return false if the passed directory does not have a .svn subdirectory
  sub test {
      my ($self, $dir) = @_;
  
      return (-d "$dir/.svn");
  }
  
  1;
APP_CMDDIRS_TRAVERSER_SUBVERSION

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE

## use critic
use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;

use App::CmdDirs;

=head1 NAME

cmddirs - perform a command in subdirectories

=head1 SYNOPSIS

cmddirs [options] command [dir ...]

If no directories are provided, cmddirs will perform the command in all
subdirectories of the current working directory.  Only subdirectories
appropriate for the given command (e.g. git repositories, if your command
    -contains the word "git") or the given directory options are acted upon.

See the man page (-man) for a full list of available directory filters.

=head1 OPTIONS

=over 4

=item B<-h|help>
Show help message

=item B<-m|man>
Show manpage

=item B<-a|all>
Perform command in all directories

=item B<-q|quiet>
Don't print out the commands as they're run

=back

=head1 FILTERS

=over 4

=item B<--git>

=item B<--svn>

=back

=head1 EXAMPLES

Check the status of all Git repos in this directory:
    gitall.pl "git status"

Check the status of the Git repos "foo" and "bar" in this directory:
    gitall.pl "git status" foo bar

=head1 AUTHOR

Drew Stephens <drew@dinomite.net>

=cut

my $options = {};
GetOptions($options,
    'help|h',
    'man|m',
    'all|a',
    'quiet|q',
    'git',
    'svn',
);

pod2usage(-verbose => 1) if ($options->{'help'});
pod2usage(-verbose => 2) if ($options->{'man'});

# We at least need a command
pod2usage(1) if (scalar(@ARGV) == 0);

my $cmdDirs = App::CmdDirs->new(\@ARGV, $options);
$cmdDirs->run();
